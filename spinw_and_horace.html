
<section>
    <style>
        .tab {
            text-indent: 40px;
        }

        .center {
            display: block;
            margin-left: auto;
            margin-right: auto;
            width: 50%;
        }

        .column {   
            float: left;
            width: 50%;
        }  
        
        /* Clear floats after the columns */ 
        .row:after {
            content: "";
            display: table;
            clear: both;
        }
        
        .defaulttable {
          display: table;
        }
        .defaulttable thead {
          display: table-header-group;
        }
        .defaulttable tbody {
          display: table-row-group;
        }
        .defaulttable tfoot {
          display: table-footer-group;
        }
        .defaulttable tbody>tr:hover,
        .defaulttable tbody>tr {
          display: table-row;
        }
        .defaulttable tbody>tr:hover>td,
        .defaulttable tbody>tr>td {
          display: table-cell;
        }
        .defaulttable,
        .defaulttable tbody,
        .defaulttable tbody>tr:hover,
        .defaulttable tbody>tr,
        .defaulttable tbody>tr:hover>td,
        .defaulttable tbody>tr>td,
        .defaulttable tbody>tr:hover>th,
        .defaulttable tbody>tr>th,
        .defaulttable thead>tr:hover>td,
        .defaulttable thead>tr>td,
        .defaulttable thead>tr:hover>th,
        .defaulttable thead>tr>th,
        .defaulttable tfoot>tr:hover>td,
        .defaulttable tfoot>tr>td,
        .defaulttable tfoot>tr:hover>th,
        .defaulttable tfoot>tr>th {
          background: transparent;
          background-color: #FFF;
          border: 0px solid #000;
          border-spacing: 0px;
          border-collapse: separate;
          empty-cells: show;
          padding: 0px;
          margin: 0px;
          outline: 0px;
          font-size: 100%;
          color: #000;
          vertical-align: top;
          text-align: left;
          font-family: sans-serif;
          table-layout: auto;
          caption-side: top;
          -webkit-border-radius: 0px;
          -moz-border-radius: 0px;
          border-radius: 0px;
          -webkit-background-clip: padding-box;
          -moz-background-clip: padding;
          background-clip: padding-box;
        }

        .limiter {
            width: 100%;
            margin: 0 auto;
        }

        .wrap-table100 {
            width: 100%;
            display: -webkit-box;
            display: -webkit-flex;
            display: -moz-box;
            display: -ms-flexbox;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-wrap: wrap;
        }

        table {
            border-spacing: 1;
            border-collapse: collapse;
            background: #F8F8F8;
            border-radius: 10px;
            overflow: hidden;
            width: 100%;
            margin: 0 auto;
            position: relative;
        }
        table * {
            position: relative;
        }
        table td, table th {
            padding-left: 8px;
        }
        table thead tr {
            height: 60px;
            background: #36304a;
        }
        table tbody tr {
            height: 50px;
        }
        table tbody tr:last-child {
            border: 0;
            border-right: none;
        }
        table tbody td:last-child {
            border-right: none;
        }
        table td, table th {
            text-align: left;
        }
        table td.l, table th.l {
            text-align: right;
        }
        table td.c, table th.c {
            text-align: center;
        }
        table td.r, table th.r {
            text-align: center;
        }


        .table100-head th{
            color: #fff;
            line-height: 1.2;
            font-weight: unset;
        }

        tbody tr:nth-child(even) {
            background-color: #E8E8E8;
        }

        tbody tr {
            color: #606060;
            line-height: 1.2;
            font-weight: unset;
        }

        tbody tr:hover {
            color: #555555;
            background-color: #f5f5f5;
            cursor: pointer;

        }

        .lastcolumn {
            text-align: right;
        }
        @media screen and (max-width: 640px) {
            table {
                overflow-x: auto;
                display: block;
            }
        }

        @media screen and (max-width: 992px) {
            table {
                display: block;
            }
            table > *, table tr, table td, table th {
                display: block;
            }
            table thead {
                display: none;
            }
            table tbody tr {
                height: auto;
                padding: 37px 0;
            }
            table tbody tr td {
                padding-left: 40% !important;
                margin-bottom: 24px;
            }
            table tbody tr td:last-child {
                margin-bottom: 0;
            }
            table tbody tr td:before {
                font-family: OpenSans-Regular;
                font-size: 14px;
                color: #999999;
                line-height: 1.2;
                font-weight: unset;
                position: absolute;
                width: 40%;
                left: 30px;
                top: 0;
            }

            tbody tr {
                font-size: 14px;
            }
        }
    </style>
    <section class="intro" id="SpinW">
        <div class="logo-wrapper">
            <div class="logo"><span class="visually-hidden">SpinW</span></div>
        </div>
    </section>
    
    <section class="title" id="title">
        <div class="grid-wrapper">
            <div class="header">
                <!-- Remove logo--full class to only show brand mark -->
                <div class="logo logo--full"><span class="visually-hidden">SpinW</span></div>
            </div>
            <div class="content">
                <h1>SpinW and Horace</h1>
                <div class="description">
                    A tutorial on how to integrate SpinW as a calculation engine in Horace.
                </div>
            </div>
            <div class="credit">
                <hr/>
                <div class="label">Presented By</div>
                <div class="name">Duc Le</div>
                <div class="role">Instrument Scientist - ISIS Facility</div>
                <div class="name">Simon Ward</div>
                <div class="role">Scientific Software Developer - ESS</div>
            </div>
        </div>
    </section>
</section>

<section>
    <section class="subsection color--radiant" id="interface_head">
    <div class="grid-wrapper">
        <div class="logo"></div>
        <h1> The Horace-SpinW interface </h1>
        <div class="description">
            How to use a SpinW model in Horace for fitting
        </div>
    </div>
    </section>

    <section class="blank" id="interface1">
        <div class="grid-wrapper">
            <div class="header">
                <div class="logo"></div>
                <div class="section">Horace recap</div>
            </div>
            <content>
                <h3> Defining models in Horace: a recap </h3>
                <p> Horace accepts a variety of functions to model data: </p>
                <table style="width:70%">
                    <tr> <td> <code> y = fn(x1, x2, ..., xn, pars) </code> </td> <td> Functions operating directly on data coordinates (e.g. gaussian peaks) </td>
                    <tr> <td> <code> s = fn(qh, qk, ql, en, pars) </code> </td> <td> Model $S(\mathbf{q},\omega)$ functions evaluated for each $\omega$ </td>
                    <tr> <td> <code> [w, s] = fn(qh, qk, ql, pars) </code> </td> <td> General model $S(\mathbf{q},\omega)$ functions </td>
                </table>
                <p> In all cases, immediately following the coordinates, Horace expects a vector of parameter values to be fitted </p>
                <p> After this parameter values, Horace also accepts any other input variables as model constants which will be passed to the model </p>
                <p> The fit functions generally only accept the <code> s = fn(qh, qk, ql, en, pars) </code> form for $S(\mathbf{q}, \omega)$ models, 
                    so energy convolution needs to be done by the modelling code </p>
            </content>
        </div>
    </section>

    <section class="blank" id="interface2">
        <div class="grid-wrapper">
            <div class="header">
                <div class="logo"></div>
                <div class="section">SpinW recap</div>
            </div>
            <content>
                <h3> The SpinW <code>spinwave</code> method: a recap </h3>
                <p> In order to calculate the spin wave spectrum in SpinW, something like the following needs to be used: </p>
                <figure class="code">
                    <pre><code class="matlab">
spec = sw_obj.spinwave(hkl, 'hermit', false, 'formfact', true);
spec = sw_egrid(spec, 'component', 'Sperp', 'Evect', 0:0.05:10);
                    </code></pre>
                </figure>
                <p> Comparing with what Horace needs, we notice that: </p>
                <div style="margin-left:40px">
                    <ul>
                        <li> The model (fittable) parameters are not set here, but much earlier in the definition of the model </li>
                        <li> We need the combination of both <code> spinwave </code> and <code> sw_egrid </code> to get a function of the
                             form <code> s = fn(qh, qk, ql, en, pars) </code> which Horace needs </li>
                    </ul>
                </div>
                <p> Fortunately the wrapped model function is provided in SpinW: the method <code> spinw.horace_sqw </code>
            </content>
        </div>
    </section>

    <section class="blank" id="interface3">
        <div class="grid-wrapper">
            <div class="header">
                <div class="logo"></div>
                <div class="section">spinw.horace_sqw</div>
            </div>
            <content>
                <h3> The <code>spinw.horace_sqw</code> method </h3>
                <p> <code> horace_sqw </code> has the same signature as a standard Horace $S(\mathbf{q}, \omega)$ function,
                    <code> horace_sqw(qh, qk, ql, en, pars, varargin) </code> </p>
                <p> So, it can be used directly in a Horace <code> multifit_sqw </code> call. <p>
                <p> In order to define which model parameter is to be varied in the fit, you have to give <code> horace_sqw </code>
                    a <code> mat </code> parameter which is a cell array of the matrix names to be varied in the order they appear in
                    the <code> pars </code> vector </p>
                <p> Since the parameters of <code> pars </code> are scalars, if the matrix you refer to is not isotropic (e.g. it's not
                    representing a Heisenberg interaction), a special syntax to refer to which matrix element(s) needs to vary has to be used. </p>
            </content>
        </div>
    </section>

    <section class="blank" id="interface4">
        <div class="grid-wrapper">
            <div class="header">
                <div class="logo"></div>
                <div class="section">spinw.horace_sqw</div>
            </div>
            <content>
                <p> A simple example: </p>
                <div class="container" style="display: grid;    grid-template-columns: 55% 5% auto;
                                                                grid-template-rows: 60% 5% auto; height: 100%;">
                    <div style="grid-column-start:1; grid-column-end:2; grid-row-start:1; grid-row-end:2">
                        <figure class="code">
                            <pre><code class="matlab">
J = 1.2;
K = 0.1;
tri = sw_model('triAF', J);
tri.addmatrix('label', 'K', 'value', diag([0 0 K]));
tri.addaniso('K');

fwhm = 0.75;
scalefactor = 1;
ws = cut_sqw(sqw_file, [0.05], [-0.1, 0.1], [-0.1, 0.1], [0.5]);
fitobj = multifit_sqw(ws);
fitobj.set_fun(@tri.horace_sqw);
fitobj.set_pin({[J K fwhm scalefactor], 'mat', {'J_1', 'K(3,3)'}, ...
    'hermit', false, 'useFast', true, 'formfact', true});
ws_sim = fitobj.simulate();
[ws_fit, fit_dat] = fitobj.fit()
                            </code></pre>
                        </figure>
                    </div>
                    <div style="grid-column-start:3; grid-column-end:4; grid-row-start:1; grid-row-end:2">
                        <p> The vector <code> [J K fwhm scalefactor] </code> is the parameters vector. We need to tell SpinW that it corresponds to the
                            Heisenberg nearest neighbour interaction <code> J_1 </code> and the easy-place anisotropy <code> K </code> </p>
                        <p> Because <code> J </code> is isotropic, we can just give the matrix name in <code> mat </code> </p>
                        <p> But, <code> K </code> only applies to the <i>zz</i> element, so we need to tell SpinW that in <code> mat </code> </p>
                        <p> <code> fwhm </code> and <code> scalefactor </code> are parameters which are added by <code> horace_sqw </code>
                            to denote the energy FWHM and intensity scale factor (may be omitted, in which case it is taken to be unity and fixed) </p>
                        <p> The other (non-varying) parameters we pass to <code> multifit </code> are just standard SpinW keyword arguments </p>
                    </div>
            </content>
        </div>
    </section>

    <section class="blank" id="interface5">
        <div class="grid-wrapper">
            <div class="header">
                <div class="logo"></div>
                <div class="section">spinw.horace_sqw</div>
            </div>
            <content>
                <p> There are a few keyword arguments unique to <code> horace_sqw </code> </p>
                <div style="margin-left:40px">
                    <ul>
                        <li> <code> 'useFast' </code> - This tells <code> horace_sqw </code> to use a faster but slightly less accurate 
                            code than <code> spinwave. </code> In particular, this code achieves a speed gain by: </li>
                            <div style="margin-left:40px">
                                <ul>
                                    <li> Only calculating <code> Sperp </code> rather than full $S^{\alpha\beta}$ tensor </li>
                                    <li> Only calculating magnon creation (positive energy / neutron energy loss) modes. </li>
                                    <li> Ignoring twins </li>
                                </ul>
                            </div>
                        <li> <code> 'partrans' </code> - A function handle to transform the input parameters received from Horace before
                            passing to SpinW </li>
                        <li> <code> 'coordtrans' </code> - A $4\times 4$ matrix to transform the input $(Q_h, Q_k, Q_l, \hbar\omega)$ coordinates
                            received from Horace before passing to SpinW </li>
                        <li> <code> 'resfun' </code> - This is tells <code> horace_sqw </code> what function to use for the energy
                            convolution. Options are: </li>
                            <div style="margin-left:40px">
                                <ul>
                                    <li> <code> 'gauss' </code> - a gaussian (one parameter: fwhm) </li>
                                    <li> <code> 'lor' </code> - a lorentzian (one parameter: fwhm) </li>
                                    <li> <code> 'voigt' </code> - a pseudovoigt (two parameters: fwhm and lorentzian fraction) </li>
                                    <li> <code> 'sho' </code> - a damped harmonic oscilator (parameters: Gamma Temperature Amplitude) </li>
                                    <li> A function handle to a function which will be accepted by Horace's <code> disp2sqw </code> method </li>
                                </ul>
                            </div>
                    </ul>
                </div>
                <p> <code> horace_sqw </code> appends the parameters needed by <code> resfun </code> to the end of the parameter
                    vector and then adds a scale factor between the data and calculation after that
            </content>
        </div>
    </section>

    <section class="blank" id="interface6">
        <div class="grid-wrapper">
            <div class="header">
                <div class="logo"></div>
                <div class="section">matparser</div>
            </div>
            <content>
                <h3> The <code> 'mat' </code> argument </h3>
                <p> Horace expects a parameter vector, so we have to tell SpinW which parameter is which </p>
                <p> In simple cases, just the name of the corresponding SpinW matrix, or a string denoting which single matrix element suffice </p>
                <p> For more complicated cases, an additional parameter <code> 'selector', </code> a $3\times3$ logical matrix needs to be used </p>
                <p> This tells the <code> matparser </code> function which SpinW uses to decode the <code> 'mat' </code> argument which matrix
                    elements the parameter corresponds to </p>
                <div class="container" style="display: grid;    grid-template-columns: 55% 5% auto;
                                                                grid-template-rows: 60% 5% auto; height: 100%;">
                    <div style="grid-column-start:1; grid-column-end:2; grid-row-start:1; grid-row-end:2">
                        <figure class="code">
                            <pre><code class="matlab">
Dvec = [0.1 0.2 0.3];
swobj.addmatrix('label', 'DM', 'value', Dvec);
swobj.addcoupling('mat', 'DM', 'bond', 1);

sel(:,:,1) = [0 0 0; 0 0 1; 0 -1 0];    % Dx
sel(:,:,2) = [0 0 1; 0 0 0; -1 0 0];    % Dy
sel(:,:,3) = [0 1 0; -1 0 0; 0 0 0];    % Dz

fitobj.set_fun(@swobj.horace_sqw);
fitobj.set_pin({Dvec, 'mat', {'DM', 'DM', 'DM'}, ...
    'selector', sel, 'hermit', false})
fitobj.fit()
                             </pre></code>
                        </figure>
                    </div>
                    <div style="grid-column-start:3; grid-column-end:4; grid-row-start:1; grid-row-end:2">
                        <p> <code> 'selector' </code> is a $3\times 3\times N$ array where $N$ is the number of parameters </p>
                        <p> Each $3\times 3$ matrix denotes which elements of the corresponding matrix in <code> 'mat' </code> goes with that parameter </p>
                    </div>
            </content>
        </div>
    </section>

</section>
    
<section>
    <section class="subsection color--radiant" id="mex_head">
    <div class="grid-wrapper">
        <div class="logo"></div>
        <h1> Mex files in SpinW </h1>
        <div class="description">
            How to speed up your calculations with parallelised compiled helper libraries
        </div>
    </div>
    </section>

    <section class="blank" id="mex1">
        <div class="grid-wrapper">
            <div class="header">
                <div class="logo"></div>
                <div class="section">Mex files</div>
            </div>
            <content>
                <h3> SpinW mex files </h3>
                <p> SpinW contains a few C libraries to speed up the spin wave calculations </p>
                <p> They perform standard linear algebra algorithms on stacks of matrices in parallel. </p>
                <table style="width:70%">
                    <tr> <td> <code> eig_omp </code> </td> <td> Calculates eigenvalues / eigenvectors of a stack of matrices </td>
                    <tr> <td> <code> chol_omp </code> </td> <td> Calculates the Cholesky factorisation of a stack of matrices </td>
                    <tr> <td> <code> sw_mtimesx </code> </td> <td> Calculates matrix-matrix or matrix-vector multiplications </td>
                </table>
                <p> For each $\mathbf{q}$ SpinW has to diagonalise or solve a Hamiltonian matrix. If this could be done in parallel
                    there will be a speed up (typically around 2-3 times for a 4-core computer). </p>
                <p> The <code> 'optmem' </code> option in <code> spinwave </code> determines how many $\mathbf{q}$'s are calculated
                    at once - the more $\mathbf{q}$'s, the greater the speed up (hence more memory is better!) </p>
            </content>
        </div>
    </section>

    <section class="blank" id="mex2">
        <div class="grid-wrapper">
            <div class="header">
                <div class="logo"></div>
                <div class="section">Using Mex files</div>
            </div>
            <content>
                <h3> Using mex files in SpinW </h3>
                <p> To tell SpinW to use the mex'ed libraries, do: </p>
                <figure class="code">
                    <pre><code class="matlab">
swpref.setpref('usemex',true)
                    </pre></code>
                </figure>
                <p> You can just type <code> swpref </code> again to show all the options </p>
                <p> If the distributed compiled mex files are not compatible with your system you will get an error </p>
            </content>
        </div>
    </section>

    <section class="blank" id="mex3">
        <div class="grid-wrapper">
            <div class="header">
                <div class="logo"></div>
                <div class="section">Compiling Mex files</div>
            </div>
            <content>
                <h3> Compiling SpinW mex files </h3>
                <p> The SpinW distribution contains compiled versions of these files for the standard 64-bit operating systems
                    (Windows, Linux and Mac OS X), but in case you need to compile it yourself... </p>
                <p> First, to compile the mex files, you will need to have installed a Matlab-compatible compiler - see:
                    <a href="https://uk.mathworks.com/support/compilers.html">https://uk.mathworks.com/support/compilers.html</a> </p>
                <p> This is generally <code> Visual Studio </code> in Windows, <code> gcc </code> on Linux and <code> XCode </code> on Mac. </p>
                <p> (Note that on Mac OS X you will need to use homebrew as OpenMP is not supported by the standard XCode compiler) </p>
                <p> Set up mex using: </p>
                <figure class="code">
                    <pre><code class="matlab">
mex -setup
                    </pre></code>
                </figure>
            </content>
        </div>
    </section>

    <section class="blank" id="mex4">
        <div class="grid-wrapper">
            <div class="header">
                <div class="logo"></div>
                <div class="section">Compiling Mex files</div>
            </div>
            <content>
                <p> Then compile the SpinW mex files with: </p>
                <figure class="code">
                    <pre><code class="matlab">
sw_mex
                    </pre></code>
                </figure>
                <p> Or: </p>
                <figure class="code">
                    <pre><code class="matlab">
sw_mex('test', true)
                    </pre></code>
                </figure>
                <p> To run a test suite which will also tell you how much of a speed up you might expect (it takes ~5min to run). </p>
            </content>
        </div>
    </section>

</section>

<section>
    <section class="subsection color--radiant" id="pcsmo_head">
    <div class="grid-wrapper">
        <div class="logo"></div>
        <h1> Example of Horace-SpinW integration </h1>
        <div class="description">
            Modelling spin waves in Pr(Ca<sub>0.9</sub>Sr<sub>0.1</sub>)<sub>2</sub>Mn<sub>2</sub>O<sub>7</sub>
            <br>
            Download the scripts here: <a href="matlab/pcsmo_eval.m" style="color: white"><code>pcsmo_eval.m</code></a>
        </div>
    </div>
    </section>

    <section class="showit color--dark" id="pcsmo1">
        <div class="grid-wrapper">
            <div class="header">
                <div class="logo"></div>
                <div class="section">Pr(Ca<sub>0.9</sub>Sr<sub>0.1</sub>)<sub>2</sub>Mn<sub>2</sub>O<sub>7 Horace data</div>
            </div>
            <content>
                <div class="profile">
                    <div class="basics">
                        <figure class="image" style="width: 80%; margin-right:10%">
                            <img src="images/pcsmo_fig2.png" alt="Fig 2 of Johnstone et al."> 
                        </figure>
                        <div class="name">Published data and simulation of Pr(Ca$_{0.9}$Sr$_{0.1}$)$_2$Mn$_2$O$_7$</div>
                        <div class="role"> </div>
                    </div>
                    <div id="details">
                        <h3> Pr(Ca<sub>0.9</sub>Sr<sub>0.1</sub>)<sub>2</sub>Mn<sub>2</sub>O<sub>7 Horace data </h3>
                        <p> The <code> .sqw </code> files should be in the folders previously used for Horace </p>
                        <p> If you're not using a desktop, you can get the files from: <a href="http://bit.ly/????" style="color: blue">
                            http://bit.ly/????</a> </p>
                        <p> Make 2D slices along $(h00)$ and energy transfer and compare to figure 2 of <a href="https://arxiv.org/pdf/1210.7108.pdf"
                            style="color: blue">Johnstone et al.</a>
                        <p> </p>
                        <figure class="code">
                            <pre><code class="matlab">
ei = [25 35 50 70 140];
proj = projaxes([1 0 0], [0 1 0]);
for ii = 1:numel(ei);
    sqw_file = sprintf('../aaa_my_work/pcsmo_ei%d_base.sqw', ei(ii));
    ws_cut(ii) = cut_sqw(sqw_file, proj, [-5,0.025,5], [-0.2,0.2], ...
        [-inf,inf], [ei(ii)/100]);
    % Symmetrise about h=0
    ws_cut(ii) = symmetrise_sqw(ws_cut(ii), [0 0 1], [0 1 0], [0 0 0]);
    plot(ws_cut(ii))
    lz 0 10
    keep_figure;
end
                            </code></pre>
                    </div>
                </div>
            </content>
        </div>
    </section>

    <section class="blank color--dark" id="pcsmo2">
        <div class="grid-wrapper">
            <div class="header">
                <div class="logo"></div>
                <div class="section"> Background subtraction </div>
            </div>
            <content>
                <h3> Background subtraction </h3>
                <p> As in the Horace tutorials, make a cut at high $q$ and use replicate to generate a 2D background slice </p>
                <p> Subtract this from the data and compare it to the paper </p>
                <figure class="code">
                    <pre><code class="matlab">
for ii = 1:numel(ei)
    idx = find(sum(ws_cut(ii).data.s,2)>0);
    qmax = ws_cut(ii).data.p{1}(idx(end)) * 0.5;
    ws_bkg(ii) = cut_sqw(ws_cut(ii), [qmax-0.1,qmax], []);
    ws_sub(ii) = ws_cut(ii) - replicate(ws_bkg(ii), ws_cut(ii));
    plot(ws_sub(ii))
    lz 0 10
    lx -2 2
    keep_figure; 
end
                    </code></pre>
                </figure>
            </content>
        </div>
    </section>

    <section class="blank color--dark" id="pcsmo3">
        <div class="grid-wrapper">
            <div class="header">
                <div class="logo"></div>
                <div class="section"> Evaluate the SpinW model </div>
            </div>
            <content>
                <h3> Evaluate the SpinW model </h3>
                <p> Use the code from the previous ("real world") tutorial to set up a SpinW model of the Goodenough model </p>
                <p> Evaluate this model on the cuts you've made: </p>
                <ul>
                    <div style="margin-left: 40px">
                    <li> Because the model had to use a larger ($2\times 2\times 1$) "structural" unit cell, we need to convert
                        the $Q_h$ and $Q_k$ coordinates given by Horace (multiply them by 2) to get the SpinW equivalent: </li>
                    </div>
                    <figure class="code">
                        <pre><code class="matlab">
cpars = {'coordtrans', diag([2 2 1 1])}
                        </code></pre>
                    </figure>
                    <div style="margin-left: 40px">
                    <li> Add the usual SpinW options: </li>
                    </div>
                    <figure class="code">
                        <pre><code class="matlab">
cpars = {cpars{:}, 'mat', {'JF1', 'JA', 'JF2', 'JF3', 'Jperp', 'D(3,3)'}, ...
    'hermit', false, 'optmem', 0, 'useFast', true, 'formfact', true, ...
    'resfun', 'gauss'};
                        </code></pre>
                    </figure>
            </content>
        </div>
    </section>

    <section class="blank color--dark" id="pcsmo4">
        <div class="grid-wrapper">
            <div class="header">
                <div class="logo"></div>
                <div class="section"> Evaluate the SpinW model </div>
            </div>
            <content>
                <p> Select the 170 meV dataset to see the overal dispersion (including gap) </p>
                <p> Then set up a multifit object on this dataset - use a <code>dnd</code> object to save time
                    (the <code>sqw</code> object will have ~100x the number of pixels) </p>
                <p> Finally tell SpinW to use mex files to speed up the calculation and evaluate the SpinW model </p>
                <figure class="code">
                    <pre><code class="matlab">
idx = 5;            % EIs: [25 35 50 70 140], index 5 == 140meV 
fwhm = ei(idx)/30;  % Typical resolution ~ 3% of Ei  

kk = multifit_sqw(d2d(ws_sub(idx)));
kk = kk.set_fun (@pcsmo.horace_sqw, {[JF1 JA JF2 JF3 Jperp D fwhm] cpars{:}}); 
kk = kk.set_free ([1, 1, 1, 1, 1, 1, 1]); 
kk = kk.set_options ('list',2);  

swpref.setpref('usemex',true);  
% Time a single iteration 
tic 
wsim = kk.simulate; 
t_spinw_single = toc;
                    </code></pre>
                </figure>
            </content>
        </div>
    </section>

    <section class="showit color--dark" id="pcsmo5">
        <div class="grid-wrapper">
            <div class="header">
                <div class="logo"></div>
                <div class="section"> Plot the simulation </div>
            </div>
            <content>
                <div class="profile">
                    <div class="basics">
                        <figure class="image" style="width: 90%; margin-right:10%">
                            <img src="images/pcsmo_spinw.png" alt="PCSMO data vs SpinW calculation"> 
                        </figure>
                        <div class="name">Published data and SpinW simulation of Pr(Ca$_{0.9}$Sr$_{0.1}$)$_2$Mn$_2$O$_7$</div>
                        <div class="role"> </div>
                    </div>
                    <div id="details">
                        <h3> Plot the simulation </h3>
                        <p> Reflect the data back to the negative $Q_h$ side, remove the empty bins (with <code> compact </code>) <p>
                        <p> Convert the data to a <code> d2d </code> object and then use <code> spaghetti_plot </code> to plot the
                            data and simulation (already a <code> d2d </code> object) together </p>
                        <p> </p>
                        <figure class="code">
                            <pre><code class="matlab">
wss = symmetrise_sqw(ws_sub(idx),[0 1 0],[0 0 1],[0 0 0]);
spaghetti_plot([compact(d2d(wss)) compact(wsim)])
lz 0 2
                            </code></pre>
                    </div>
                </div>
            </content>
        </div>
    </section>

</section>


<section>
    <section class="subsection color--radiant" id="fe_fit_head">
    <div class="grid-wrapper">
        <div class="logo"></div>
        <h1> Example of Horace-SpinW fitting </h1>
        <div class="description">
            Fitting spin waves in bcc-Iron with SpinW and Horace
            <br>
            Download the scripts here: <a href="matlab/fe_fit.m" style="color: white"><code>fe_fit.m</code></a>
        </div>
    </div>
    </section>

    <section class="blank color--dark" id="fe_fit1">
        <div class="grid-wrapper">
            <div class="header">
                <div class="logo"></div>
                <div class="section"> Make cuts of Fe data </div>
            </div>
            <content>
                <p> Make the set of standard $Q_h$ 1D cuts at different energies as before </p>
                <figure class="code">
                    <pre><code class="matlab">
proj = projaxes([1 1 0], [-1 1 0]);
energy_range = [80:20:160];
for i = 1:numel(energy_range)
    my_cuts(i) = cut_sqw(sqw_file, proj, [-3,0.05,3], [-1.05,-0.95], [-0.05,0.05], ...
        [-10 10]+energy_range(i)); 
end
                    </code></pre>
                </figure>
                <p> Run the same fits with the analytical $S(\mathbf{q},\omega)$ function as before
                    and note the fitted parameters and how long it takes </p>
            </content>
        </div>
    </section>

    <section class="blank color--dark" id="fe_fit2">
        <div class="grid-wrapper">
            <div class="header">
                <div class="logo"></div>
                <div class="section"> SpinW model </div>
            </div>
            <content>
                <p> Define a SpinW model for bcc-Fe with a single nearest neighbour exchange and
                    a small easy axis anisotropy </p>
                <figure class="code">
                    <pre><code class="matlab">
a = 2.87;

fe = spinw;
fe.genlattice('lat_const', [a a a], 'angled', [90 90 90], 'spgr', 'I m -3 m')  % bcc Fe
fe.addatom('label', 'MFe3', 'r', [0 0 0], 'S', 5/2, 'color', 'gold')
fe.gencoupling()
fe.addmatrix('label', 'J1', 'value', 1, 'color', 'gray')
fe.addmatrix('label', 'D', 'value', diag([0 0 -1]), 'color', 'green')
fe.addcoupling('mat', 'J1', 'bond', 1)
fe.addaniso('D')
fe.genmagstr('mode', 'direct', 'S', [0 0 1; 0 0 1]');  % Ferromagnetic

plot(fe, 'range', [2 2 2])
                    </code></pre>
                </figure>
            </content>
        </div>
    </section>

    <section class="blank color--dark" id="fe_fit3">
        <div class="grid-wrapper">
            <div class="header">
                <div class="logo"></div>
                <div class="section"> SpinW model </div>
            </div>
            <content>
                <p> Set the parameters for the fits, and also SpinW options </p>
                <p> Note that the analytical expression used previous for $S(\mathbf{q},\omega)$
                    used $JS$, whereas SpinW uses $J$, and we have defined $S=\frac{5}{2}$ </p>
                <figure class="code">
                    <pre><code class="matlab">
% Initial parameters:
J = -16;
D = -0.1;
gam = 66;
temp = 10;
amp = 131;

cpars = {'mat', {'J1', 'D(3,3)'}, 'hermit', false, 'optmem', 1, ...
    'useFast', true, 'resfun', 'sho', 'formfact', true}; 
swpref.setpref('usemex',true);  
                    </code></pre>
                </figure>
                <p> Notice that we use the <code> sho </code> resolution function, in common with
                    the analytical expressions </p>
                <p> Because the cuts are small, we also force SpinW to calculate all q-points in
                    one chunk with the <code> {'optmem', 1} </code> option.
            </content>
        </div>
    </section>

    <section class="blank color--dark" id="fe_fit4">
        <div class="grid-wrapper">
            <div class="header">
                <div class="logo"></div>
                <div class="section"> SpinW model </div>
            </div>
            <content>
                <p> Set up the multifit object on the array of 1D cuts </p>
                <p> Use the <code> horace_sqw </code> method as the fit function and parameters
                    as defined previously, and run the fit </p>
                <figure class="code">
                    <pre><code class="matlab">
kk = multifit_sqw (my_cuts);
kk = kk.set_fun (@fe.horace_sqw, {[J D gam temp amp] cpars{:}});
kk = kk.set_free ([1, 0, 1, 0, 1]);
kk = kk.set_bfun (@linear_bg, [0.1,0]);
kk = kk.set_bfree ([1,0]);
kk = kk.set_options ('list',2);

[wfit, fitdata] = kk.fit('comp');
                    </code></pre>
                </figure>
                <p> Compare the fits - are the parameters or correlation matrix consistent? </p>
            </content>
        </div>
    </section>


</section>

